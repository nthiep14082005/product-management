// phần này là đang code theo hướng sever side rendering
// từ bài 33 28tech nodejs là code theo hướng client side rendering



MVC là viết tắt của Model - View - Controller, mỗi thành phần trong MVC đều có nhiệm vụ riêng. Model: đây là nơi tương tác trực tiếp với dữ liệu hoặc hệ quản trị cơ sở dữ liệu. Nó bao gồm các class chứa các phương thức kết nối với database, truy vấn, thêm/xóa/sửa dữ liệu.


dang hoc den bai 19 - 1:50:00 day file len git /////////////////







Sự khác biệt giữa req.query và req.body khi dùng form là do thuộc tính method của thẻ form:

Nếu form dùng method="GET":
 → Dữ liệu sẽ được gửi lên URL dưới dạng query string (sau dấu ?), bạn lấy bằng req.query.
 Ví dụ:
 html  <form method="GET" action="/search">    <input name="keyword">  </form>    Khi submit: /search?keyword=abc
 → Server lấy bằng req.query.keyword

Nếu form dùng method="POST":
 → Dữ liệu sẽ được gửi trong phần thân (body) của request, bạn lấy bằng req.body.
 Ví dụ:
 html  <form method="POST" action="/add">    <input name="title">  </form>    Khi submit: dữ liệu nằm trong body
 → Server lấy bằng req.body.title

Tóm lại:

method="GET" → dùng req.query
method="POST" (hoặc PATCH/PUT/DELETE với method-override) → dùng req.body
Lý do: Chuẩn HTTP quy định GET gửi dữ liệu qua URL, còn POST gửi qua body.


























bat dau bai 20




bai 20 -> 7ph giải thích về tại sao sử dụng method use hoặc get



// phút thứ 59 bài 21 28tech nodejs là insert data vào thêm


// học git và github ở bài 4 - 28tech - nodejs -> 2:00:00


// thay đổi thứ tự sản phẩm 28tech bài 23 -> 54:40
// dang học đến bài 24 - 1:59:00 - hiển thị thông báo sau khi ...



// bat dau hoc validate du lieu bai 25 28tech 33:00



// bat dau bai 26 - nodejs - 28tech 0:44:00ph -> bắt đầu deploy project backend lên web sử dụng mongodb atlas

bai 26- nodejs 28tech 1:04:00 -> cách connect vào database mongodb online


// bat dau bai 27 - nodejs - 28tech 0:19:00ph -> đẩy file tĩnh lên cloud



// bat dau bai 27 - nodejs - 28tech 1:12:00ph -- sắp xếp các sản phẩm theo các tiêu chí khác nhau , TinyMCE, quản lý danh sách sản phẩm 




// bat dau bai 28 - nodejs - 28tech 0:00:00ph -> TinyMCE 



// bat dau bai 28 - nodejs - 28tech 1:15:00ph  -> để lưu được sản phẩm vào database thì đầu tiên phải tạo model vào sau khi tạo xong thì exports ra và trong controller thì sử dụng bằng cách gọi const Product = require(... đường dẫn của model cần lưu vào database ...)


// bat dau bai 29 - nodejs - 28tech 0:06:00ph -> làm drop down để lấy ra được đệ quy danh sách danh mục cha bên fe



// bat dau bai 29 - nodejs - 28tech 0:29:00ph --> sử dụng tree bên backend để phân cấp danh mục cha con 
//     Hàm đi sâu đến node cuối cùng trước (đệ quy), xử lý xong node con rồi mới quay lại node cha để gán children. 
//     Quá trình này lặp lại cho đến khi hoàn thành cây phân cấp.
//     Bạn hiểu đúng về cách hoạt động của hàm này!
    function createTree (array, parentId = "") {
        const tree = [];
        array.forEach((item) => {
            if(item.parent_id === parentId) {
                const newItem = item;
                const children = createTree(array, item.id);
                if(children.length > 0) {
                    newItem.newChildren = children;
                }
                tree.push(newItem);
            }
        })
        return tree;
    }

    Tóm tắt giải thích về newChildren:

Mục đích sử dụng:
newChildren là thuộc tính được tạo ra để lưu trữ mảng các danh mục con trực tiếp của một danh mục cha trong cây phân cấp.
Nhờ đó, bạn có thể dễ dàng truy xuất và hiển thị các nhánh con của từng danh mục khi render ra giao diện.

Cách lưu trữ giá trị:
Khi hàm đệ quy createTree tìm thấy một danh mục con, nó sẽ gán mảng các con này vào thuộc tính newChildren của object cha (newItem).
Ví dụ:

Mỗi object danh mục trong cây sẽ có thuộc tính newChildren nếu nó có con.

Phạm vi tồn tại:

newChildren chỉ tồn tại trong từng object danh mục được tạo ra trong quá trình duyệt mảng và xây cây.
Khi object này được push vào mảng kết quả (tree), nó sẽ giữ lại toàn bộ dữ liệu, bao gồm cả thuộc tính newChildren.
Sau khi hàm chạy xong, toàn bộ cây (bao gồm các object và thuộc tính newChildren) sẽ được lưu trong biến kết quả (ví dụ: newRecords), và bạn có thể sử dụng để render ra view hoặc xử lý tiếp.
Tóm lại:

newChildren giúp xây dựng cấu trúc cây phân cấp, lưu trữ các nhánh con của từng danh mục.
Mỗi object danh mục sẽ có thuộc tính này nếu nó có con, và dữ liệu được lưu trong chính object đó, tồn tại trong cây kết quả cuối cùng.



    const newRecords = createTree(records);
    console.log(newRecords);









khi sử dụng join vào mảng 
                //- Không phải như vậy!
                //- Kết quả của Array(4).join("abc") là chuỗi "abcabcabc", nhưng không có khoảng trắng đầu tiên.

                //- Giải thích chi tiết:

                //- Array(4) tạo ra mảng có 4 phần tử rỗng: [ , , , ]
                //- Khi .join("abc"), nó sẽ nối giữa các phần tử rỗng bằng chuỗi "abc".
                //- Vì mảng có 4 phần tử, sẽ có 3 vị trí để nối, nên kết quả là "abcabcabc".
                //- Không có phần tử nào ở đầu hoặc cuối, chỉ có chuỗi nối giữa các phần tử.









TƯƠNG TỰ THÌ 
// join
["a", "b", "c"].join("-") // Kết quả: "a-b-c" -> join sẽ chèn dấu - vào giữa các phần tử trong mảng được cách nhau bởi dấu phẩy

// split
"a-b-c".split("-") // Kết quả: ["a", "b", "c"] -> split sẽ tách chuyển đổi dấu mình muốn truyền vào split và trở thành dấu phẩy




còn ví dụ ta có parentIdLevel = 1 mà sau đó gọi là Array(parentIdLevel + 1) tức là ban đầu Array(1) tức là có 1 phần tử là -> []
và Array(parentIdLevel + 1) là Array(2) tức là tạo ra -> [ , ]; 2 phần tử khoảng trắng và khi này có join("--") tức là ta sẽ được [khoảng trắng thứ 1--khoảng trắng thứ 2]













// bat dau bai 30 - nodejs - 28tech 01:09:00ph ->>>> bắt đầu xây dựng phân quyền, nhóm quyền 
B1: tạo nhóm quyền -> đầu tiên tạo 1 collections tên là roles 1:10:00
B2: Xây dựng danh sách nhóm quyền -> 1:26:00
B3: 

Thêm mới, chỉnh sửa sản phẩm có danh mục của category






// bat dau bai 31 - nodejs - 28tech 00:17:00ph ->>> giải thích kỹ làm thế nào để phân quyền





// bat dau bai 32 - nodejs - 28tech 00:20:00ph 